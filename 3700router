#!/usr/bin/env -S python3 -u

from __future__ import annotations
import argparse, socket, time, json, select, struct, sys, math

class Router:

    relations = {} # map: ip -> relation
    sockets = {} # map: ip -> socket objects
    ports = {} # map: ip -> port

    neighbors = [] # the ips of all our neighbors

    forwardingTable = [] # our list of rows in the fowarding table. always appending.
    allAnnouncements = [] # record of all announcements weve receieved



    # converting decimal to binary
    # and removing the prefix(0b)
    def decimalToBinary(n):
        return bin(n).replace("0b", "")

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")
            self.neighbors.append(neighbor)

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # sockets[neigbborsIP] = socket obj
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def sendHelper(self, msg: str, type: str, toIP: str, destination: str):
        self.send(toIP, json.dumps({ "type": type, "src": self.our_addr(toIP), "dst": destination, "msg": msg  }))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')

                print("Received message '%s' from %s" % (msg, srcif))
                self.parseMsg(json.loads(msg), sock)
        return
        
    # take in the json msg object
    # note to self: if type != data, then fromNeighbor = src. else, the src may not be a neighbor
    def parseMsg(self, announcement, fromNeighbor):
        type = announcement["type"]
        src = announcement["src"]
        dst = announcement["dst"]
        msg = announcement["msg"]

        # DUMP
        if type == 'dump':
            rows = []
            for msg in self.forwardingTable:
                rows.append(msg)
            self.sendHelper(rows, "table", src, src)

        # UPDATE
        if type == 'update':
            self.allAnnouncements.append(announcement) # append the whole announcement to list
            msg['peer'] = src
            self.forwardingTable.append(msg)           # append the routing information we get to our table

            aspath: list = msg["ASPath"]
            modifiedASPath = aspath.copy()
            modifiedASPath.insert(0, self.asn)         # prepend it to the list
            publicMsg = {"network": msg["network"], "netmask": msg["netmask"], "ASPath": modifiedASPath}

            recievedFrom = self.relations[src]
            # send updates to all other neighbors
            if recievedFrom == "cust":
                self.sendToNeighbors(publicMsg, "update", src)
            else:
                self.sendToNeighbors(publicMsg, "update", src, False)

        # DATA
        if type == 'data':
            bestRoutes = self.getBestRoute(dst)
            
            if len(bestRoutes) == 1:                                    # case: one best route
                bestRouteIP = bestRoutes[0]['peer']
                if self.isCustomerPacket(fromNeighbor, dst):
                    self.sendHelper(msg, "data", bestRouteIP, dst)
                else:
                    self.sendHelper("{}", "no route", fromNeighbor, fromNeighbor)

            elif len(bestRoutes) > 1:                                   # case: multiple best routes
                bestRoute = self.tieWinner(bestRoutes)
                bestRouteIP = bestRoute['peer']
                if self.isCustomerPacket(fromNeighbor, dst):
                    self.sendHelper(msg, "data", bestRouteIP, dst)
                else:
                    self.sendHelper("{}", "no route", fromNeighbor, fromNeighbor)


                return
            else:                                                       # case: no best route
                self.sendHelper("{}", "no route", fromNeighbor, fromNeighbor)


    #compares bestRoutes to determine which should win the tie
    def tieWinner(self, bestRoutes):
        largestLocal = 0;
        wonTie = []
        for msg in bestRoutes:
            if msg['localpref'] > largestLocal:
                largestLocal = msg['localpref']
                wonTie = [msg]
            if msg['localpref'] == largestLocal:
                wonTie.append(msg)
        #print("current winners for local pref", wonTie)
        bestRoutes = wonTie
        wonTie = []
        if len(bestRoutes) > 1:
            for msg in bestRoutes:
                if msg['selfOrigin']:
                    wonTie.append(msg)
            #print("current winners for selfOrigin", wonTie)
            if len(wonTie) != 0:
                bestRoutes = wonTie
            wonTie = []
            if len(bestRoutes) > 1:
                shortestAS = len(bestRoutes[0]['ASPath'])
                for msg in bestRoutes:
                    if len(msg['ASPath']) < shortestAS:
                        shortestAS = msg['ASPath']
                        wonTie = [msg]
                    if len(msg['ASPath']) == shortestAS:
                        wonTie.append(msg)
                #print("current winners for shortestASPath", wonTie)
                bestRoutes = wonTie
                wonTie = []
                if len(bestRoutes) > 1:
                    for msg in bestRoutes:
                        if msg['origin'] == 'IGP':
                            wonTie.append(msg)
                    if len(wonTie) == 0:
                        wonTie = []
                        for msg in bestRoutes:
                            if msg['origin'] == 'EGP':
                                wonTie.append(msg)
                        if len(wonTie) == 0:
                            wonTie = bestRoutes
                    #print("current winners for highest origin", wonTie)
                    bestRoutes = wonTie
                    wonTie = []
                    if len(bestRoutes) > 1:
                        lowestIP = self.quadsToBinary(bestRoutes[0]['network'])
                        lowestIP = int(lowestIP, 2)
                        wonTie = [msg]
                        for msg in bestRoutes:
                            ip = self.quadsToBinary(msg['network'])
                            ip = int(ip, 2)
                            if ip < lowestIP:
                                lowestIP = ip
                                wonTie = [msg]
                        bestRoutes = wonTie
                        #print('final winner', bestRoutes)
                        #print('\n\n\n\n\n')
                        return bestRoutes[0]
        if len(bestRoutes) > 0:
            return bestRoutes[0]

        # str of quads -> bin

    def quadsToBinary(self, IPstring):
        toBin = lambda n: bin(n).replace("0b", "").zfill(8)  # 32 bit value
        quads = list(int(i) for i in IPstring.split('.'))
        return ''.join(list(map(toBin, quads)))



    # returns the array containing the the best route(s)-- 0 or more-- to forward the data packet to,
    # based on an xnor of the masking result and the destination
    def getBestRoute(self, dest):
        destbinary = self.quadsToBinary(dest)

        bestRoutes = [] # may end up having 0 or more
        longestMatch = 0

        for msg in self.forwardingTable:
            # perform masking
            networkbinary = self.quadsToBinary(msg['network'])
            netmaskbinary = self.quadsToBinary(msg['netmask'])
            maskingresult = format((int(networkbinary, 2) & int(netmaskbinary, 2)),"032b")


            # xnor netmaskbinary with destbinary
            numMatching = self.prefixMatchLength(destbinary, maskingresult)
            if numMatching > longestMatch:
                longestMatch = numMatching     # new longest matching prefix
                bestRoutes = [msg]
            elif numMatching == longestMatch:  # equally as good a match
                bestRoutes.append(msg)
        return bestRoutes

    # uses xnor to determine how many characters the two strings match bits for
    def prefixMatchLength(self, a: str, b: str):
        if len(a) != len(b):
            print('\n\n\nerror in prefixMatchLength, args had diff lengths!\n\n\n')
        res = 0
        for i in range(len(a)):
            if a[i] != b[i]:
                break
            else:
                res = res + 1

        return res

    # returns true if either the dest or src of the data packet is a cust
    def isCustomerPacket(self, srcIP, dstIP):
        return (srcIP in self.relations.keys() and self.relations[srcIP] == "cust") or (dstIP in self.relations.keys() and self.relations[dstIP] == "cust")


    # forward msgToSend to every relation except for the srcIP (where it came from), and non-customers, if specified by bool
    def sendToNeighbors(self, msg: str, type: str, srcIP: str, everyone = True):
        for n in self.neighbors:
            if n != srcIP and (everyone or self.relations[n] == "cust"):
                self.send(n, json.dumps({ "type": type, "src": self.our_addr(n), "dst": n, "msg": msg  }))


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()

