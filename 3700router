#!/usr/bin/env -S python3 -u
import argparse, socket, json, select
from ast import Num
from itertools import combinations

class Router:

    relations = {}
    sockets = {}
    ports = {}

    neighbors = [] # the ips of all our neighbors
    forwardingTable = [] # our list of rows in the fowarding table. always appending.
    allAnnouncements = [] # record of all announcements weve receieved

    def decimalToBinary(n):
        return bin(n).replace("0b", "")

    def quadsToBinary(self, IPstring):
        toBin = lambda n: bin(n).replace("0b", "").zfill(8)
        quads = list(int(i) for i in IPstring.split('.'))
        return ''.join(list(map(toBin, quads)))

    def __init__(self, asn, connections):
        print("Router at AS %s starting up" % asn)
        self.asn = asn
        for relationship in connections:
            port, neighbor, relation = relationship.split("-")
            self.neighbors.append(neighbor)

            self.sockets[neighbor] = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # sockets[neigbborsIP] = socket obj
            self.sockets[neighbor].bind(('localhost', 0))
            self.ports[neighbor] = int(port)
            self.relations[neighbor] = relation
            self.send(neighbor, json.dumps({ "type": "handshake", "src": self.our_addr(neighbor), "dst": neighbor, "msg": {}  }))

    def our_addr(self, dst):
        quads = list(int(qdn) for qdn in dst.split('.'))
        quads[3] = 1
        return "%d.%d.%d.%d" % (quads[0], quads[1], quads[2], quads[3])

    def send(self, network, message):
        self.sockets[network].sendto(message.encode('utf-8'), ('localhost', self.ports[network]))

    def sendHelper(self, msg: str, type: str, toIP: str, destination: str):
        self.send(toIP, json.dumps({ "type": type, "src": self.our_addr(toIP), "dst": destination, "msg": msg  }))

    def run(self):
        while True:
            socks = select.select(self.sockets.values(), [], [], 0.1)[0]
            for conn in socks:
                k, addr = conn.recvfrom(65535)
                srcif = None
                for sock in self.sockets:
                    if self.sockets[sock] == conn:
                        srcif = sock
                        break
                msg = k.decode('utf-8')

                print("Received message '%s' from %s" % (msg, srcif))
                self.parseMsg(json.loads(msg), sock)
        return

    def countOnes(self, s: str):
        numOnes = 0
        for c in s:
            if c == "1":
                numOnes+=1

        return numOnes

    def buildNewNewmask(self, numOnes: Num):
        res = ''
        for n in range(numOnes):
            res += '1'

        numZeros = 32 - numOnes

        for n in range(numZeros):
            res += '0'

        return res


    def checkForAggregation(self):
        print('\n\nCHECKING FOR AGGR\n\n')
        if len(self.forwardingTable) < 2:
            print('\n\n ONLY ONE ENTRY')
            return 

        for i, pair in enumerate(combinations(self.forwardingTable, 2)):
            print('pair ', i, ':\n')
            print(pair, '\n')

            # aggregate those which are adj numerically
            if self.numericallyAdjacent2(pair[0], pair[1]):
                print('\n\n ADJACENT!! ')
   
                if pair[0]['peer'] == pair[1]['peer'] and pair[0]['localpref'] == pair[1]['localpref'] and pair[0]['origin'] == pair[1]['origin'] and pair[0]['selfOrigin'] == pair[1]['selfOrigin']:
                    
                    # the network for the aggregate entry is the lower network IP
                    if int(self.quadsToBinary(pair[0]['network']), 2) < int(self.quadsToBinary(pair[1]['network']), 2):
                        minNetwork = pair[0]
                    else:
                        minNetwork = pair[1]


                    # the netmask for the aggregate has one less 1
                    netmaskInBin = self.quadsToBinary(pair[1]['netmask'])
                    numOnes = self.countOnes(netmaskInBin)

                    # new netmask is numOnes - 1, concatenated with 0s to fill out the rest of the 32 bits
                    newNetmask = self.buildNewNewmask(numOnes - 1)

                    # 32 bit str --> 4 8 bit strs
                    byteLen = 8
                    quadsAsBin = [newNetmask[i:i+byteLen] for i in range(0, len(newNetmask), byteLen)]
                    quadsAsInts = map(lambda quad: str(int(quad, 2)), quadsAsBin)
                    res = '.'.join(quadsAsInts)

                    aggregatedMsg = {
                        "network": minNetwork["network"], 
                        "netmask": res, 
                        "localpref": pair[0]['localpref'], 
                        "origin": pair[0]['origin'], 
                        "selfOrigin": pair[0]['selfOrigin'], 
                        "ASPath":  pair[0]['ASPath'], 
                        "peer":  pair[0]['peer']
                    }

                    self.forwardingTable = list(filter(lambda entry: (entry['network'] != pair[0]["network"]) and (entry['network'] != pair[1]["network"]), self.forwardingTable))
                    self.forwardingTable.append(aggregatedMsg)
                    # self.checkForAggregation()
                    # print('NEW FT:', self.forwardingTable, '\n\n')
            else:
                print("\nCannot aggregate\n\n")


    # takes in a msg['network'] and msg['netmask'], returns the maskingresult in binary
    def performMasking(self, network: str, netmask: str):
        print('\nperforming masking')
        networkbinary = self.quadsToBinary(network)
        print('\nnetworkbinary = ', networkbinary)
        netmaskbinary = self.quadsToBinary(netmask)
        print('\nnetmaskbinary = ', netmaskbinary)

        # count num of ones in mask
        maskVal = self.countOnes(netmaskbinary)
        maskingresult = networkbinary[:maskVal]

        # maskingresult = bin(int(networkbinary, 2) & int(netmaskbinary, 2)).replace("0b", "")
        print('\nmasking res = ', maskingresult)
        return maskingresult


    # checks if message networks are adjacent by comparing lengths after masking
    def numericallyAdjacent2(self, aMsg: str, bMsg: str):
        maskingResA = self.performMasking(aMsg['network'], aMsg['netmask'])
        maskingResB= self.performMasking(bMsg['network'], bMsg['netmask'])

        return len(maskingResA) == len(maskingResB)
    
    # take in the json msg object
    # note to self: if type != data, then fromNeighbor = src. else, the src may not be a neighbor
    def parseMsg(self, announcement, fromNeighbor):
        type = announcement["type"]
        src = announcement["src"]
        dst = announcement["dst"]
        msg = announcement["msg"]

        # DUMP
        if type == 'dump':
            rows = []
            for msg in self.forwardingTable:
                rows.append(msg)
            self.sendHelper(rows, "table", src, src)

        # UPDATE
        if type == 'update':
            self.allAnnouncements.append(announcement) # append the whole announcement to list
            msg['peer'] = src
            self.forwardingTable.append(msg)           # append the routing information we get to our table
            self.checkForAggregation()

            aspath: list = msg["ASPath"]
            modifiedASPath = aspath.copy()
            modifiedASPath.insert(0, self.asn)         # prepend it to the list
            publicMsg = {"network": msg["network"], "netmask": msg["netmask"], "ASPath": modifiedASPath}

            recievedFrom = self.relations[src]
            # send updates to all other neighbors
            if recievedFrom == "cust":
                self.sendToNeighbors(publicMsg, "update", src)
            else:
                self.sendToNeighbors(publicMsg, "update", src, False)

        if type == 'withdraw':
            self.allAnnouncements.append(announcement) # append the whole announcement to list
            for revoked in msg:
                res = list(filter(lambda i: i['network'] == revoked['network'] and i['netmask'] == revoked['netmask']
                                 and i['peer'] == src, self.forwardingTable))[0]
                print('\n\n\n\n\n OUR RESULT')
                print(res)
                self.forwardingTable.remove(res)

            recievedFrom = self.relations[src]
            if recievedFrom == "cust":
                self.sendToNeighbors(msg, "withdraw", src)
            else:
                self.sendToNeighbors(msg, "withdraw", src, False)


        # DATA
        if type == 'data':
            bestRoutes = self.getBestRoute(dst)
            
            if len(bestRoutes) == 1:                                    # case: one best route
                bestRouteIP = bestRoutes[0]['peer']
                if self.isCustomerPacket(fromNeighbor, bestRouteIP):
                    self.sendHelper(msg, "data", bestRouteIP, dst)
                else:
                    self.sendHelper("{}", "no route", fromNeighbor, fromNeighbor)

            elif len(bestRoutes) > 1:                                   # case: multiple best routes
                bestRoute = self.tieWinner(bestRoutes)
                bestRouteIP = bestRoute['peer']
                if self.isCustomerPacket(fromNeighbor, bestRouteIP):
                    self.sendHelper(msg, "data", bestRouteIP, dst)
                else:
                    self.sendHelper("{}", "no route", fromNeighbor, fromNeighbor)


                return
            else:                                                       # case: no best route
                self.sendHelper("{}", "no route", fromNeighbor, fromNeighbor)


    # use xnor to see how many matching bits between the given binary strings
    def prefixMatchLength(self, destbinary: str, maskingresult: str):
        res = 0
        maxIndex = min(len(maskingresult), len(destbinary))
        for i in range(maxIndex):
            if destbinary[i] != maskingresult[i]:
                break
            else:
                res += 1
        return res

    # check if either the destination or src of the packet is a customer
    def isCustomerPacket(self, srcIP, dstIP):
        return (srcIP in self.relations.keys() and self.relations[srcIP] == "cust") or (dstIP in self.relations.keys() and self.relations[dstIP] == "cust")

    # forward message to every relation except for the source ip (where it came from) and non-customers
    def sendToNeighbors(self, msg: str, type: str, srcIP: str, everyone = True):
        for n in self.neighbors:
            if n != srcIP and (everyone or self.relations[n] == "cust"):
                self.send(n, json.dumps({"type": type, "src": self.our_addr(n), "dst": n, "msg": msg  }))

    
    #compares bestRoutes to determine which should win the tie
    def tieWinner(self, bestRoutes):
        largestLocal = 0
        wonTie = []
        for msg in bestRoutes:
            if msg['localpref'] > largestLocal:
                largestLocal = msg['localpref']
                wonTie = [msg]
            if msg['localpref'] == largestLocal:
                wonTie.append(msg)
        #print("current winners for local pref", wonTie)
        bestRoutes = wonTie
        wonTie = []
        if len(bestRoutes) > 1:
            for msg in bestRoutes:
                if msg['selfOrigin']:
                    wonTie.append(msg)
            #print("current winners for selfOrigin", wonTie)
            if len(wonTie) != 0:
                bestRoutes = wonTie
            wonTie = []
            if len(bestRoutes) > 1:
                shortestAS = len(bestRoutes[0]['ASPath'])
                for msg in bestRoutes:
                    if len(msg['ASPath']) < shortestAS:
                        shortestAS = msg['ASPath']
                        wonTie = [msg]
                    if len(msg['ASPath']) == shortestAS:
                        wonTie.append(msg)
                #print("current winners for shortestASPath", wonTie)
                bestRoutes = wonTie
                wonTie = []
                if len(bestRoutes) > 1:
                    for msg in bestRoutes:
                        if msg['origin'] == 'IGP':
                            wonTie.append(msg)
                    if len(wonTie) == 0:
                        wonTie = []
                        for msg in bestRoutes:
                            if msg['origin'] == 'EGP':
                                wonTie.append(msg)
                        if len(wonTie) == 0:
                            wonTie = bestRoutes
                    #print("current winners for highest origin", wonTie)
                    bestRoutes = wonTie
                    wonTie = []
                    if len(bestRoutes) > 1:
                        lowestIP = self.quadsToBinary(bestRoutes[0]['network'])
                        lowestIP = int(lowestIP, 2)
                        wonTie = [msg]
                        for msg in bestRoutes:
                            ip = self.quadsToBinary(msg['network'])
                            ip = int(ip, 2)
                            if ip < lowestIP:
                                lowestIP = ip
                                wonTie = [msg]
                        bestRoutes = wonTie
                        #print('final winner', bestRoutes)
                        #print('\n\n\n\n\n')
                        return bestRoutes[0]
        if len(bestRoutes) > 0:
            return bestRoutes[0]

    # returns the array containing the best route(s) to forward the data packet to
    def getBestRoute(self, dest):
        destbinary = self.quadsToBinary(dest)

        # there will be zero or more best routes
        bestRoutes = [] 
        longestMatch = 0

        for msg in self.forwardingTable:
            maskingresult = self.performMasking(msg['network'], msg['netmask'])

            numMatching = self.prefixMatchLength(destbinary, maskingresult)
            if numMatching > longestMatch:
                longestMatch = numMatching    # new best match
                bestRoutes = [msg]
            elif numMatching == longestMatch: # equally as good a match
                bestRoutes.append(msg)
        return bestRoutes


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='route packets')
    parser.add_argument('asn', type=int, help="AS number of this router")
    parser.add_argument('connections', metavar='connections', type=str, nargs='+', help="connections")
    args = parser.parse_args()
    router = Router(args.asn, args.connections)
    router.run()

